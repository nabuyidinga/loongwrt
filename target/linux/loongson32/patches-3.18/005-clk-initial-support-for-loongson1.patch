From fa9a6baac5a2712597f0400394cec7d272547af5 Mon Sep 17 00:00:00 2001
From: Rosy Song <rosysong@rosinson.com>
Date: Sun, 2 Dec 2018 15:51:33 +0800
Subject: [PATCH 2/9] clk: initial support for loongson1

Signed-off-by: Rosy Song <rosysong@rosinson.com>
---
 drivers/clk/clk-ls1x.c | 162 ++++++++++++++++++++++++++++++++++-------
 1 file changed, 135 insertions(+), 27 deletions(-)

diff --git a/drivers/clk/clk-ls1x.c b/drivers/clk/clk-ls1x.c
index f20b7502..6126e9bb 100644
--- a/drivers/clk/clk-ls1x.c
+++ b/drivers/clk/clk-ls1x.c
@@ -15,8 +15,7 @@
 
 #include <loongson1.h>
 
-#define OSC	33
-
+extern unsigned long ls1x_osc_clk;
 static DEFINE_SPINLOCK(_lock);
 
 static int ls1x_pll_clk_enable(struct clk_hw *hw)
@@ -34,10 +33,13 @@ static unsigned long ls1x_pll_recalc_rate(struct clk_hw *hw,
 	u32 pll, rate;
 
 	pll = __raw_readl(LS1X_CLK_PLL_FREQ);
-	rate = ((12 + (pll & 0x3f)) * 1000000) +
-		((((pll >> 8) & 0x3ff) * 1000000) >> 10);
-	rate *= OSC;
-	rate >>= 1;
+
+#if defined(CONFIG_LOONGSON1_LS1C)
+	rate = (((pll >> 8) & 0xff) + ((pll >> 16) & 0xff)) * ls1x_osc_clk / 4;
+#else
+	rate = (12 + (pll & 0x3f)) * ls1x_osc_clk / 2
+			+ ((pll >> 8) & 0x3ff) * ls1x_osc_clk / 1024 / 2;
+#endif
 
 	return rate;
 }
@@ -78,34 +80,140 @@ static struct clk * __init clk_register_pll(struct device *dev,
 	return clk;
 }
 
+static const char const *cpu_parents[] = { "cpu_clk_div", "osc_clk", };
+static const char const *ahb_parents[] = { "ahb_clk_div", "osc_clk", };
+static const char const *dc_parents[] = { "dc_clk_div", "osc_clk", };
+
 void __init ls1x_clk_init(void)
 {
 	struct clk *clk;
-
-	clk = clk_register_pll(NULL, "pll_clk", NULL, CLK_IS_ROOT);
-	clk_prepare_enable(clk);
-
-	clk = clk_register_divider(NULL, "cpu_clk", "pll_clk",
-			CLK_SET_RATE_PARENT, LS1X_CLK_PLL_DIV, DIV_CPU_SHIFT,
-			DIV_CPU_WIDTH, CLK_DIVIDER_ONE_BASED, &_lock);
-	clk_prepare_enable(clk);
-	clk_register_clkdev(clk, "cpu", NULL);
-
+	u32 ctrl;
+
+	clk = clk_register_fixed_rate(NULL, "osc_clk", NULL, CLK_IS_ROOT,
+				      ls1x_osc_clk);
+	clk_register_clkdev(clk, "osc_clk", NULL);
+
+	/* clock derived from 33 MHz OSC clk */
+	clk = clk_register_pll(NULL, "pll_clk", "osc_clk", 0);
+	clk_register_clkdev(clk, "pll_clk", NULL);
+
+	/* clock derived from PLL clk */
+	/*                                 _____
+	 *         _______________________|     |
+	 * OSC ___/                       | MUX |___ CPU CLK
+	 *        \___ PLL ___ CPU DIV ___|     |
+	 *                                |_____|
+	 */
+#if defined(CONFIG_LOONGSON1_LS1A)
+	/*
+	* FIXME : As there still a bug when read value form PLL register(0xbfe78030)
+	* of Loongson 1A CPU, the value of cpu frequency is transfered from
+	* PMON (bootloader) in fact.
+	*/
+	clk = clk_register_fixed_factor(NULL, "cpu_clk", "osc_clk", 0, 8, 1);
+	clk_register_clkdev(clk, "cpu_clk", NULL);
+#elif defined(CONFIG_LOONGSON1_LS1B)
+	clk = clk_register_divider(NULL, "cpu_clk_div", "pll_clk",
+				   CLK_GET_RATE_NOCACHE, LS1X_CLK_PLL_DIV,
+				   DIV_CPU_SHIFT, DIV_CPU_WIDTH,
+				   CLK_DIVIDER_ONE_BASED |
+				   CLK_DIVIDER_ROUND_CLOSEST, &_lock);
+	clk_register_clkdev(clk, "cpu_clk_div", NULL);
+	clk = clk_register_mux(NULL, "cpu_clk", cpu_parents,
+			       ARRAY_SIZE(cpu_parents),
+			       CLK_SET_RATE_NO_REPARENT, LS1X_CLK_PLL_DIV,
+			       BYPASS_CPU_SHIFT, BYPASS_CPU_WIDTH, 0, &_lock);
+	clk_register_clkdev(clk, "cpu_clk", NULL);
+#else
+	ctrl = __raw_readl(LS1X_CLK_PLL_DIV);
+	if (ctrl & DIV_CPU_SEL) {
+		if(ctrl & DIV_CPU_EN) {
+			clk = clk_register_divider(NULL, "cpu_clk", "pll_clk",
+					CLK_SET_RATE_PARENT, LS1X_CLK_PLL_DIV, DIV_CPU_SHIFT,
+					DIV_CPU_WIDTH, CLK_DIVIDER_ONE_BASED, &_lock);
+		} else {
+			clk = clk_register_fixed_factor(NULL, "cpu_clk", "pll_clk", 0, 1, 2);
+		}
+	}
+	clk_register_clkdev(clk, "cpu_clk", NULL);
+#endif
+
+	/*                                 _____
+	 *         _______________________|     |
+	 * OSC ___/                       | MUX |___ DC  CLK
+	 *        \___ PLL ___ DC  DIV ___|     |
+	 *                                |_____|
+	 */
+#if defined(CONFIG_LOONGSON1_LS1A)
+	/*
+	* FIXME : As there still a bug when read value form PLL register(0xbfe78030)
+	* of Loongson 1A CPU, the value of cpu frequency is transfered from
+	* PMON (bootloader) in fact.
+	*/
+#elif defined(CONFIG_LOONGSON1_LS1B)
+	clk = clk_register_divider(NULL, "dc_clk_div", "pll_clk",
+				   0, LS1X_CLK_PLL_DIV, DIV_DC_SHIFT,
+				   DIV_DC_WIDTH, CLK_DIVIDER_ONE_BASED, &_lock);
+	clk_register_clkdev(clk, "dc_clk_div", NULL);
+	clk = clk_register_mux(NULL, "dc_clk", dc_parents,
+			       ARRAY_SIZE(dc_parents),
+			       CLK_SET_RATE_NO_REPARENT, LS1X_CLK_PLL_DIV,
+			       BYPASS_DC_SHIFT, BYPASS_DC_WIDTH, 0, &_lock);
+	clk_register_clkdev(clk, "dc_clk", NULL);
+#else
 	clk = clk_register_divider(NULL, "dc_clk", "pll_clk",
 			CLK_SET_RATE_PARENT, LS1X_CLK_PLL_DIV, DIV_DC_SHIFT,
 			DIV_DC_WIDTH, CLK_DIVIDER_ONE_BASED, &_lock);
-	clk_prepare_enable(clk);
-	clk_register_clkdev(clk, "dc", NULL);
-
-	clk = clk_register_divider(NULL, "ahb_clk", "pll_clk",
-			CLK_SET_RATE_PARENT, LS1X_CLK_PLL_DIV, DIV_DDR_SHIFT,
-			DIV_DDR_WIDTH, CLK_DIVIDER_ONE_BASED, &_lock);
-	clk_prepare_enable(clk);
-	clk_register_clkdev(clk, "ahb", NULL);
+	clk_register_clkdev(clk, "dc_clk", NULL);
+#endif
+
+	/*                                 _____
+	 *         _______________________|     |
+	 * OSC ___/                       | MUX |___ DDR CLK
+	 *        \___ PLL ___ DDR DIV ___|     |
+	 *                                |_____|
+	 */
+#if defined(CONFIG_LOONGSON1_LS1A)
+	/*
+	* FIXME : As there still a bug when read value form PLL register(0xbfe78030)
+	* of Loongson 1A CPU, the value of cpu frequency is transfered from
+	* PMON (bootloader) in fact.
+	*/
+	clk = clk_register_fixed_factor(NULL, "ahb_clk", "osc_clk", 0, 4, 1);
+#elif defined(CONFIG_LOONGSON1_LS1B)
+	clk = clk_register_divider(NULL, "ahb_clk_div", "pll_clk",
+				   0, LS1X_CLK_PLL_DIV, DIV_DDR_SHIFT,
+				   DIV_DDR_WIDTH, CLK_DIVIDER_ONE_BASED,
+				   &_lock);
+	clk_register_clkdev(clk, "ahb_clk_div", NULL);
+	clk = clk_register_mux(NULL, "ahb_clk", ahb_parents,
+			       ARRAY_SIZE(ahb_parents),
+			       CLK_SET_RATE_NO_REPARENT, LS1X_CLK_PLL_DIV,
+			       BYPASS_DDR_SHIFT, BYPASS_DDR_WIDTH, 0, &_lock);
+#else
+	ctrl = __raw_readl(LS1X_CLK_PLL_FREQ) & 0x3;
+	switch (ctrl) {
+		case 0:
+			clk = clk_register_fixed_factor(NULL, "ahb_clk", "cpu_clk", 0, 1, 2);
+		break;
+		case 1:
+			clk = clk_register_fixed_factor(NULL, "ahb_clk", "cpu_clk", 0, 1, 4);
+		break;
+		case 2:
+		case 3:
+			clk = clk_register_fixed_factor(NULL, "ahb_clk", "cpu_clk", 0, 1, 3);
+		break;
+	}
+#endif
+	clk_register_clkdev(clk, "ahb_clk", NULL);
 	clk_register_clkdev(clk, "stmmaceth", NULL);
 
-	clk = clk_register_fixed_factor(NULL, "apb_clk", "ahb_clk", 0, 1, 2);
-	clk_prepare_enable(clk);
-	clk_register_clkdev(clk, "apb", NULL);
+	/* clock derived from AHB clk */
+	/* APB clk is always half of the AHB clk */
+	clk = clk_register_fixed_factor(NULL, "apb_clk", "ahb_clk", 0, 1,
+					DIV_APB);
+	clk_register_clkdev(clk, "apb_clk", NULL);
+	clk_register_clkdev(clk, "ls1x_spi", NULL);
+	clk_register_clkdev(clk, "ls1x_wdt", NULL);
 	clk_register_clkdev(clk, "serial8250", NULL);
 }
-- 
2.17.0

